â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                â•‘
â•‘                   ğŸ“– MANDY AI - COMPLETE BOT MANUAL & GUIDE ğŸ“–                  â•‘
â•‘                                                                                â•‘
â•‘              Everything you need to understand and operate your bot              â•‘
â•‘                                                                                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


âš¡ QUICK START (3 COMMANDS TO GET RUNNING)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Install dependencies:
   pip install discord.py aiofiles aiomysql

2. Set up your bot token:
   â€¢ Edit main.py line 5251 with your Discord bot token
   â€¢ Or set environment variable DISCORD_BOT_TOKEN

3. Run the bot:
   python main.py

âœ… Bot is now online and listening to commands!


â“ WHY THIS BOT EXISTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MANDY AI is a Discord bot designed to:

â€¢ ğŸ¯ Smart Command Processing: Users type NATURALLY (no syntax required)
  Instead: "dm john hello"
  Not:     "!dm @john hello"
  Not:     "!sendmessage user_id=123 text=hello"

â€¢ ğŸ“Š User Activity Tracking: Track who's talking, when, and how much
  - Daily/weekly/monthly statistics
  - User message counts
  - Server-wide metrics

â€¢ ğŸ‘ï¸ Watchers System: Auto-notify users based on activity
  - "Watch john after 5 messages say hey"
  - Automatically triggers actions at message thresholds

â€¢ ğŸ”„ Channel Mirroring: Sync messages between channels
  - "Mirror #general to #backup"
  - One-way or two-way message relay

â€¢ ğŸ’¬ DM Bridge: Relay messages between Discord and direct messages
  - History tracking
  - User presence awareness
  - Rich message formatting

â€¢ ğŸ” Role-Based Permissions: Granular access control
  - Guest, Staff, Admin, God levels
  - Per-command capability restrictions
  - Hot-reload capabilities without restart

â€¢ âš¡ Rate Limiting: Protect from spam and abuse
  - Per-user cooldowns
  - Per-command rate limits
  - Graceful backoff system

â€¢ ğŸ¤– AI Integration: Optional Google Gemini AI support
  - Natural conversations
  - Context-aware responses
  - Tool design & building


ğŸ“ SYSTEM ARCHITECTURE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CORE FILES:

[1] main.py (5251 lines)
    â””â”€ Discord.py bot setup & initialization
    â””â”€ Command prefix parsing (!)
    â””â”€ Rate limiting, cooldowns, database management
    â””â”€ Web server hosting (optional)
    â””â”€ Admin/God-level command handlers
    â””â”€ Server population & pinned docs

[2] cogs/mandy_ai.py (2193 lines)
    â””â”€ Main command cog for Mandy
    â””â”€ Message handling pipeline
    â””â”€ All user-facing commands (dm, watchers, mirrors, stats, etc.)
    â””â”€ Intelligent command processor integration
    â””â”€ Response formatting & confirmation

[3] intelligent_command_processor.py (759 lines)
    â””â”€ Natural language processing engine
    â””â”€ Intent recognition via regex patterns
    â””â”€ Argument extraction & fuzzy matching
    â””â”€ Context memory & pronoun resolution
    â””â”€ Smart clarification questions
    â””â”€ User-friendly result formatting

SUPPORT FILES:

[4] capability_registry.py
    â””â”€ Tracks enabled/disabled bot capabilities
    â””â”€ Per-guild capability configuration
    â””â”€ Tool plugin registration

[5] tool_plugin_manager.py
    â””â”€ Dynamic tool loading system
    â””â”€ Plugin validation & execution
    â””â”€ Error handling & recovery

[6] intelligence_layer.py
    â””â”€ Unified AI processing interface
    â””â”€ Model routing (Gemini, local, etc.)
    â””â”€ Response parsing & formatting

[7] resolver.py
    â””â”€ Guild member/role resolution
    â””â”€ Fuzzy name matching
    â””â”€ Permission checking

[8] extensions/
    â”œâ”€â”€ validator.py
    â”‚   â””â”€ Command validation framework
    â”‚
    â”œâ”€â”€ validator_unrestricted.py
    â”‚   â””â”€ Bypass validation for trusted commands
    â”‚
    â””â”€â”€ tool_ping.py
        â””â”€ Ping/latency checking tool

CONFIG & UTILITIES:

[9] update_restrictions.py
    â””â”€ Manage permission restrictions
    â””â”€ Update role requirements dynamically

[10] cooldown_store.py
     â””â”€ Rate limit & cooldown tracking
     â””â”€ Per-user cooldown management

[11] clarify_ui.py
     â””â”€ Disambiguation UI for confused commands
     â””â”€ Smart question generation

[12] quick_wins.py
     â””â”€ Helper utilities & shortcuts

[13] verify_integration.py
     â””â”€ Verification script for checking system health

DOCUMENTATION:

[14] docs/
     â”œâ”€â”€ INTEGRATION_COMPLETE.txt       â† Overview of intelligent layer
     â”œâ”€â”€ README_INTELLIGENT_SYSTEM.txt  â† Quick integration guide
     â”œâ”€â”€ QUICK_REFERENCE.txt            â† Command patterns & examples
     â”œâ”€â”€ SYSTEM_SUMMARY.txt             â† Complete system overview
     â”œâ”€â”€ MANDY_MANUAL.md                â† Original manual
     â”œâ”€â”€ MANDY_MANUAL.txt               â† Text version
     â””â”€â”€ COMPLETE_BOT_MANUAL.txt        â† THIS FILE


ğŸ¯ HOW COMMANDS FLOW THROUGH THE SYSTEM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STEP 1: USER SENDS MESSAGE
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User: "dm john hello"                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“

STEP 2: BOT RECEIVES MESSAGE (main.py)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ on_message() event triggered                                    â”‚
â”‚ â€¢ Check if message starts with prefix (!)                      â”‚
â”‚ â€¢ Extract command & arguments                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“

STEP 3: MANDY COG PROCESSING (cogs/mandy_ai.py)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ _handle_fast_path() method:                                     â”‚
â”‚ 1. Check rate limits (cooldown_store.py)                       â”‚
â”‚ 2. Verify permissions (resolver.py)                            â”‚
â”‚ 3. Try INTELLIGENT PROCESSOR first (NEW!)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“

STEP 4A: INTELLIGENT LAYER (intelligent_command_processor.py)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ IntentRecognizer:                                               â”‚
â”‚ â”œâ”€ Matches "dm john hello" against 27 regex patterns            â”‚
â”‚ â”œâ”€ Detects action: "send_dm"                                   â”‚
â”‚ â”œâ”€ Confidence: 0.95                                             â”‚
â”‚ â””â”€ Returns match groups: ["john", "hello"]                     â”‚
â”‚                                                                 â”‚
â”‚ ArgumentExtractor:                                              â”‚
â”‚ â”œâ”€ Extract target user: "john"                                 â”‚
â”‚ â”œâ”€ Extract message: "hello"                                    â”‚
â”‚ â”œâ”€ Fuzzy match names (jon â†’ john)                              â”‚
â”‚ â””â”€ Resolve pronouns from context                               â”‚
â”‚                                                                 â”‚
â”‚ ContextMemory:                                                  â”‚
â”‚ â”œâ”€ Check user history (last 20 actions)                        â”‚
â”‚ â”œâ”€ Store new action                                            â”‚
â”‚ â””â”€ Enable pronoun resolution ("him" â†’ last mentioned user)     â”‚
â”‚                                                                 â”‚
â”‚ ClarificationHandler:                                           â”‚
â”‚ â”œâ”€ If ambiguous: ask "Which john? (john#1, john#2, ...)"      â”‚
â”‚ â””â”€ If confident: proceed                                       â”‚
â”‚                                                                 â”‚
â”‚ _ManydAICommandExecutor:                                        â”‚
â”‚ â”œâ”€ Execute send_dm(targets=[john_id], text="hello")           â”‚
â”‚ â””â”€ Handle success/errors                                       â”‚
â”‚                                                                 â”‚
â”‚ ConfirmationFormatter:                                          â”‚
â”‚ â”œâ”€ Create human-friendly response                              â”‚
â”‚ â””â”€ Send embed to Discord                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“ (if successful)
STEP 5: ACTION EXECUTED & CONFIRMED
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ… Message sent to john                                        â”‚
â”‚ âœ… Response sent to original user                              â”‚
â”‚ âœ… Action logged to database                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        OR (if intelligent processor failed)
                            â†“

STEP 4B: TRADITIONAL FALLBACK (Traditional parsing)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Use original syntax-based parsing                               â”‚
â”‚ â€¢ Still fully functional                                        â”‚
â”‚ â€¢ Guarantees 100% compatibility                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ® USER COMMANDS (WHAT USERS CAN DO)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1ï¸âƒ£  SEND DIRECT MESSAGES (8+ natural variations)
    WHY: Send private messages without leaving Discord

    EXAMPLES:
    â€¢ "dm @john hello"
    â€¢ "message john 'how are you'"
    â€¢ "tell john hi"
    â€¢ "john hi"
    â€¢ "send hello to john"
    â€¢ "message hello john"
    â€¢ "write john thanks for the help"
    â€¢ "ping john check this out"

    WHAT HAPPENS:
    âœ“ Bot finds user "john" (fuzzy matching)
    âœ“ Sends DM with your message
    âœ“ Confirms with you
    âœ— No errors if user not found


2ï¸âƒ£  MONITOR USERS (WATCHERS)
    WHY: Auto-send message after user sends N messages

    EXAMPLES:
    â€¢ "watch john after 5 messages say hey"
    â€¢ "monitor john and say hey every 5 messages"
    â€¢ "add watcher john 5 say hey"
    â€¢ "watch john say hello"

    WHAT HAPPENS:
    âœ“ Bot tracks john's message count
    âœ“ When count reaches threshold â†’ bot sends message
    âœ“ Count resets, repeats


3ï¸âƒ£  REMOVE WATCHERS
    WHY: Stop monitoring a user

    EXAMPLES:
    â€¢ "stop watching john"
    â€¢ "remove watcher john"
    â€¢ "unwatch john"
    â€¢ "delete watcher john"

    WHAT HAPPENS:
    âœ“ Watcher removed
    âœ“ No more auto-messages for that user


4ï¸âƒ£  LIST ACTIVE WATCHERS
    WHY: See who you're currently watching

    EXAMPLES:
    â€¢ "show watchers"
    â€¢ "list watchers"
    â€¢ "what watchers are active"
    â€¢ "get watchers"

    WHAT HAPPENS:
    âœ“ Shows all active watchers
    âœ“ Displays target user, message count, trigger message


5ï¸âƒ£  MIRROR CHANNELS
    WHY: Sync messages between two channels

    EXAMPLES:
    â€¢ "mirror #general to #backup"
    â€¢ "link #channel1 and #channel2"
    â€¢ "sync #a with #b"

    WHAT HAPPENS:
    âœ“ Messages in source â†’ forwarded to dest
    âœ“ Can be one-way or two-way
    âœ“ Useful for backups, relay channels, etc.


6ï¸âƒ£  SHOW STATISTICS
    WHY: See who's talking the most and when

    EXAMPLES:
    â€¢ "show stats"
    â€¢ "stats daily"
    â€¢ "how much has john messaged today"
    â€¢ "get stats for this week"

    WHAT HAPPENS:
    âœ“ Shows top talkers
    âœ“ Message counts per user
    âœ“ Timeframe: daily/weekly/monthly


7ï¸âƒ£  CHECK BOT HEALTH
    WHY: Verify bot is running properly

    EXAMPLES:
    â€¢ "health"
    â€¢ "status"
    â€¢ "check bot status"

    WHAT HAPPENS:
    âœ“ Shows bot latency
    âœ“ Connection status
    âœ“ Uptime


8ï¸âƒ£  VIEW JOB QUEUE
    WHY: See pending background tasks

    EXAMPLES:
    â€¢ "queue"
    â€¢ "show queue"
    â€¢ "check jobs"

    WHAT HAPPENS:
    âœ“ Lists pending operations
    âœ“ Shows priority & estimated time
    âœ“ Helps identify bottlenecks


ğŸ” PERMISSION LEVELS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BOT USES 5 PERMISSION TIERS:

1. GUEST (Level 0)
   â””â”€ Public users with basic access
   â””â”€ Can: use public commands, view stats
   â””â”€ Cannot: admin operations, restrict others

2. STAFF (Level 20)
   â””â”€ Server moderators
   â””â”€ Can: manage watchers, mirror channels, ban users
   â””â”€ Cannot: full admin operations

3. ADMIN (Level 50)
   â””â”€ Server administrators
   â””â”€ Can: all staff commands, manage roles, restart features
   â””â”€ Cannot: modify core bot settings

4. GOD (Level 90)
   â””â”€ Bot owner / super admin
   â””â”€ Can: everything
   â””â”€ Can: modify capabilities, manage plugins, reload system

5. AUTO_GOD (Special ID)
   â””â”€ Creator account
   â””â”€ Can: emergency shutdown, system restore, force updates

HOW TO CHECK YOUR LEVEL:
  - Bot replies with your current permission level in embeds
  - Higher level = more commands available
  - Levels are per-guild (different in each server)


âš™ï¸ INSTALLATION & CONFIGURATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

REQUIREMENT 1: Python 3.8+
  Download from: https://www.python.org/downloads/

REQUIREMENT 2: Discord Bot Token
  1. Go to: https://discord.com/developers/applications
  2. Click "New Application"
  3. Set name: "Mandy AI"
  4. Go to "Bot" â†’ Create Bot
  5. Copy token (keep secret!)

REQUIREMENT 3: Install Dependencies
  pip install discord.py aiofiles aiomysql

OPTIONAL: Google Gemini API (for AI features)
  1. Go to: https://aistudio.google.com/
  2. Create API key
  3. Save to passwords.txt file

STEP 1: Edit main.py
  â€¢ Find line 5251 (bottom of file)
  â€¢ Replace TOKEN_HERE with your Discord bot token
  â€¢ Or: Set environment variable DISCORD_BOT_TOKEN

STEP 2: Create database.json (auto-created on first run)
  â€¢ Stores user data, watchers, mirrors
  â€¢ Auto-backed up daily

STEP 3: Optional - Enable MySQL
  â€¢ Edit main.py, find DB connection settings
  â€¢ Set: MYSQL_HOST, MYSQL_USER, MYSQL_PASSWORD, MYSQL_DB
  â€¢ Bot will use MySQL if available, falls back to JSON

STEP 4: Run the bot
  python main.py

STEP 5: Verify in Discord
  â€¢ Go to your test server
  â€¢ Type: !help
  â€¢ Should see command list


ğŸ”§ ADMINISTRATION & TROUBLESHOOTING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ADMIN COMMANDS (God-level only):

[1] Reload Capabilities
    !reload_capabilities
    â””â”€ Reloads capability registry without restart

[2] Update Command Restrictions
    !restrict <command> <level>
    â””â”€ Set minimum permission level for command
    â””â”€ Example: !restrict dm 20 (only Staff+)

[3] View System Status
    !status
    â””â”€ Shows: uptime, latency, message count, user count
    â””â”€ Available to all levels

[4] Emergency Shutdown
    !shutdown
    â””â”€ Graceful bot shutdown
    â””â”€ Preserves all data
    â””â”€ God-level only

[5] View Logs
    !logs [count]
    â””â”€ Show recent system log entries
    â””â”€ Default: last 50 lines

[6] Hot Reload Tools
    !reload_tools
    â””â”€ Reload tool plugins without restart
    â””â”€ Useful after updates


TROUBLESHOOTING:

PROBLEM: "Bot not responding"
FIX:
  1. Check Discord bot token is valid
  2. Verify bot has permissions in server
  3. Check firewall/network connection
  4. Restart: python main.py

PROBLEM: "Commands give 'permission denied' error"
FIX:
  1. Check your permission level: !status
  2. Ask server admin to increase your level
  3. Ensure bot has message send permissions

PROBLEM: "Database errors when running watchers"
FIX:
  1. Delete database.json (auto-recreated)
  2. Or: Fix MySQL connection settings
  3. Check disk space

PROBLEM: "Intelligent processor not responding"
FIX:
  1. Verify intelligent_command_processor.py exists
  2. Check syntax: python -m py_compile intelligent_command_processor.py
  3. Restart bot to reload module

PROBLEM: "Rate limit errors"
FIX:
  1. Wait 1 hour (rate limits reset)
  2. Check you're not spamming commands
  3. Ask admin to increase your rate limit


ğŸ“Š DATABASE STRUCTURE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DATABASE.JSON FORMAT:

{
  "watchers": {
    "user_id": {
      "target_user_id": {
        "count": 5,
        "current": 2,
        "text": "hey",
        "created_at": 1234567890,
        "triggered_count": 3
      }
    }
  },
  "mirrors": {
    "source_channel_id": {
      "destinations": [dest_id1, dest_id2],
      "created_by": "user_id",
      "created_at": 1234567890
    }
  },
  "message_count": {
    "channel_id": {
      "user_id": {
        "count": 42,
        "last_message": 1234567890,
        "last_message_timestamp": "2026-01-13 10:30:00"
      }
    }
  },
  "cooldowns": {
    "user_id": {
      "command": {
        "last_used": 1234567890,
        "expires": 1234567950
      }
    }
  }
}

IMPORTANT:
  âœ“ All timestamps are Unix epoch (seconds since 1970)
  âœ“ Auto-backed up to database.json.bak daily
  âœ“ User IDs are Discord numeric IDs (not usernames)
  âœ“ Channel IDs are Discord numeric IDs


ğŸ¨ INTELLIGENT COMMAND PROCESSOR DETAILS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

WHY IT EXISTS:
  Traditional bots require users learn syntax. MANDY lets users type naturally!

WHAT IT DOES:
  Takes raw user input â†’ extracts intent & arguments â†’ executes command

HOW IT WORKS:

[1] INTENT RECOGNITION
    â€¢ Runs 27 regex patterns against user input
    â€¢ Finds first match
    â€¢ Returns action name & confidence score
    â€¢ Example: "dm john hi" â†’ action: "send_dm", confidence: 0.95

[2] ARGUMENT EXTRACTION
    â€¢ Extracts groups from regex match
    â€¢ Converts to named arguments
    â€¢ Example: groups ["john", "hi"] â†’ target: "john", message: "hi"

[3] FUZZY NAME MATCHING
    â€¢ Matches "jon" â†’ "john" (handles typos)
    â€¢ Matches "john123" â†’ "John#1234" (Discord format)
    â€¢ Uses difflib.SequenceMatcher for similarity

[4] CONTEXT MEMORY
    â€¢ Stores user action history (last 20 actions)
    â€¢ Enables pronoun resolution
    â€¢ Example: User says "him" â†’ bot looks up last mentioned user

[5] PRONOUN RESOLUTION
    â€¢ Resolves: him, her, them, it, that, those
    â€¢ Uses context memory
    â€¢ Example: 
      User: "message john hello"
      Bot: [stores john as context]
      User: "tell him secret"
      Bot: Resolves "him" â†’ john

[6] CLARIFICATION QUESTIONS
    â€¢ If ambiguous: asks user to clarify
    â€¢ Example: "Which john? (john#1234, john#5678, john#9012)"
    â€¢ Waits for user response with emoji reaction

[7] COMMAND EXECUTION
    â€¢ Passes confirmed arguments to executor
    â€¢ Executor (_ManydAICommandExecutor) runs actual command
    â€¢ Handles all 8 command types

[8] RESPONSE FORMATTING
    â€¢ Formats human-friendly response
    â€¢ Creates Discord embeds
    â€¢ Includes success/error details


ğŸ“ˆ EXAMPLE CONVERSATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EXAMPLE 1: Simple DM

USER: "message john hello"

BOT PROCESSING:
  â€¢ IntentRecognizer: Matches pattern â†’ action: "send_dm"
  â€¢ ArgumentExtractor: Extracts ["john", "hello"]
  â€¢ Lookup: Finds user john (discord ID: 123456)
  â€¢ Execute: send_dm([123456], "hello")
  â€¢ Format: "âœ… Sent 'hello' to john"

BOT RESPONSE:
  âœ… Message sent successfully!
  Target: john
  Message: hello


EXAMPLE 2: Watcher with Pronoun Resolution

USER: "watch john after 5 messages say hey"

BOT PROCESSING:
  â€¢ IntentRecognizer: Matches pattern â†’ action: "add_watcher"
  â€¢ ArgumentExtractor: Extracts ["john", "5", "hey"]
  â€¢ ContextMemory: Stores [john, 5, hey] in user history
  â€¢ Execute: add_watcher(123456, 5, "hey")
  â€¢ Format: "âœ… Now watching john. After 5 messages, I'll say: 'hey'"

LATER:

USER: "tell him to stop talking"

BOT PROCESSING:
  â€¢ Detects command includes pronoun "him"
  â€¢ ContextMemory lookup: last user was john
  â€¢ Resolves: "him" â†’ john
  â€¢ Execute: remove_watcher(123456)

BOT RESPONSE:
  âœ… Stopped watching john


EXAMPLE 3: Ambiguous Command (Clarification)

USER: "message john hello"
[Note: There are 2 users named john in the guild]

BOT PROCESSING:
  â€¢ ArgumentExtractor: Fuzzy matches "john"
  â€¢ Finds: john#1234 (confidence 0.9), john#5678 (confidence 0.88)
  â€¢ ClarificationHandler: Too close, need to ask

BOT RESPONSE:
  â“ Which john did you mean?
  
  1ï¸âƒ£  john#1234 (most active)
  2ï¸âƒ£  john#5678 (joined yesterday)
  
  React with number to confirm!

USER: [Reacts with 1ï¸âƒ£]

BOT PROCESSING:
  â€¢ Detects reaction
  â€¢ User confirmed: john#1234
  â€¢ Execute: send_dm([123456], "hello")

BOT RESPONSE:
  âœ… Message sent to john#1234!


ğŸ’¾ PERFORMANCE & SCALABILITY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DESIGNED FOR:
  âœ“ 10,000+ users
  âœ“ 100+ guilds
  âœ“ 1,000,000+ messages per day

OPTIMIZATION TECHNIQUES:
  â€¢ Async/await throughout (non-blocking)
  â€¢ Rate limiting prevents overload
  â€¢ Context memory capped at 20 items
  â€¢ Database queries cached
  â€¢ Lazy loading of user data

MEMORY USAGE:
  â€¢ Base: ~50MB
  â€¢ Per 1000 users: +5MB
  â€¢ Per 10,000 messages in context: +2MB
  â€¢ Total typical: 100-200MB

RESPONSE TIME:
  â€¢ Simple command (dm): <100ms
  â€¢ Complex command (stats): <500ms
  â€¢ With clarification: <1000ms


ğŸš€ ADVANCED FEATURES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[1] DM BRIDGE
    Relay messages between Discord and DMs
    â€¢ Two-way relay
    â€¢ Message history
    â€¢ User presence tracking
    â€¢ Rich formatting (embeds, attachments)

[2] STATS SYSTEM
    Track message activity across time
    â€¢ Per-user stats
    â€¢ Per-channel stats
    â€¢ Per-guild stats
    â€¢ Multiple timeframes: daily, weekly, monthly, yearly
    â€¢ Top talkers ranking

[3] MIRROR CHANNELS
    Sync messages between Discord channels
    â€¢ One-way or two-way
    â€¢ Message history preservation
    â€¢ Edit/delete sync
    â€¢ Supports forwarding to multiple destinations

[4] TOOL PLUGINS
    Extend bot with custom tools
    â€¢ tool_ping.py: Check Discord latency
    â€¢ validator.py: Validate commands before execution
    â€¢ validator_unrestricted.py: Skip validation for trusted commands
    â€¢ Custom tools can be added in extensions/

[5] CAPABILITY REGISTRY
    Enable/disable features dynamically
    â€¢ Per-guild configuration
    â€¢ Hot-reload without restart
    â€¢ Fallback when features unavailable
    â€¢ Track what's enabled/disabled

[6] INTELLIGENCE LAYER (Optional)
    Google Gemini AI integration
    â€¢ Natural conversation support
    â€¢ Context-aware responses
    â€¢ Tool design assistance
    â€¢ Code building help
    â€¢ Rate limited to prevent abuse


ğŸ”’ SECURITY & SAFETY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BUILT-IN PROTECTIONS:

[1] PERMISSION LAYERS
    â€¢ 5 permission tiers (Guest â†’ God)
    â€¢ Per-command restrictions
    â€¢ Per-guild configuration
    â€¢ Role-based access control

[2] RATE LIMITING
    â€¢ Per-user cooldowns
    â€¢ Per-command limits
    â€¢ Backoff system (exponential wait)
    â€¢ Global rate limits

[3] INPUT VALIDATION
    â€¢ Argument type checking
    â€¢ Length limits (prevents spam)
    â€¢ Regex validation
    â€¢ Extension validation before execution

[4] AUDIT LOGGING
    â€¢ All actions logged to database
    â€¢ Timestamp for every operation
    â€¢ User ID of who ran command
    â€¢ Result (success/failure)

[5] DATABASE SECURITY
    â€¢ No plaintext passwords in code
    â€¢ Config in separate passwords.txt
    â€¢ Database backups daily
    â€¢ Optional MySQL for encrypted storage

[6] ERROR HANDLING
    â€¢ Graceful fallback on errors
    â€¢ No sensitive data in error messages
    â€¢ Rate limit exceptions don't crash bot
    â€¢ Partial failure doesn't break entire command


ğŸ“š INTEGRATION WITH DISCORD
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BOT PERMISSIONS REQUIRED:

Essential:
  âœ“ Send Messages
  âœ“ Embed Links
  âœ“ Read Messages/View Channels
  âœ“ Read Message History
  âœ“ Manage Messages (for command cleanup)

Recommended:
  âœ“ Mention @everyone / @here (for pinged responses)
  âœ“ Add Reactions (for confirmation reactions)
  âœ“ Use External Emojis (for pretty UI)
  âœ“ Manage Roles (for role assignment if configured)

HOW TO GRANT PERMISSIONS:

1. In Discord server, right-click Mandy AI bot
2. Click "Manage Bot"
3. Enable permissions listed above
4. Make sure bot role is ABOVE any roles it needs to manage

DISCORD SERVER SETUP:

Recommended:
  1. Create "Bot Logs" channel â†’ bot logs admin actions
  2. Create "Pinned Docs" channel â†’ auto-pin instructions
  3. Create "DM Bridge" channel â†’ relay DMs from users
  4. Create "Stats" channel â†’ post daily statistics
  5. Set role "Bot Manager" for users who manage bot

Optional:
  â€¢ Create private channels for sensitive operations
  â€¢ Pin important bot documentation
  â€¢ Set up custom command prefix (!m instead of !)


ğŸ¤– GOOGLE GEMINI AI INTEGRATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

WHY INTEGRATE AI:
  â€¢ Natural conversation support
  â€¢ Context-aware responses
  â€¢ Auto-complete commands
  â€¢ Design & building assistance

HOW TO SET UP:

[1] Get API Key
    â€¢ Visit: https://aistudio.google.com/
    â€¢ Sign in with Google account
    â€¢ Create API key (free tier available)

[2] Store API Key
    â€¢ Create file: passwords.txt
    â€¢ Add line: GEMINI_API_KEY=your_key_here
    â€¢ Keep file private!

[3] Test Integration
    â€¢ Type in Discord: "!test_ai"
    â€¢ Should respond from Gemini

[4] Configure Behavior
    â€¢ Edit cogs/mandy_ai.py
    â€¢ Find GeminiClient class
    â€¢ Adjust max_tokens, temperature, etc.

HOW IT WORKS:

User: "explain quantum computing"
  â†“
Intelligence Layer (intelligence_layer.py)
  â”œâ”€ Check if needs AI
  â”œâ”€ Route to Gemini via genai library
  â”œâ”€ Send: model="gemini-pro", input="explain quantum computing"
  â””â”€ Receive: "Quantum computing uses quantum bits..."
  â†“
Format Response
  â”œâ”€ Split into Discord message chunks (<2000 chars)
  â”œâ”€ Create embeds with citations
  â””â”€ Send to Discord

RATE LIMITS:
  â€¢ Gemini free tier: 60 requests per minute
  â€¢ Bot applies local backoff: 1s between requests
  â€¢ Handles rate limits gracefully
  â€¢ Queue system for pending requests


ğŸ“ LOGGING & MONITORING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LOG LOCATIONS:

[1] Console Output
    â””â”€ When running: python main.py
    â””â”€ Shows: startup messages, errors, debug info

[2] Discord Bot Logs Channel
    â””â”€ Auto-created in server
    â””â”€ Posts: major events, errors, admin actions
    â””â”€ Searchable in Discord history

[3] database.json
    â””â”€ All user data, watchers, mirrors
    â””â”€ Auto-formatted JSON
    â””â”€ Backup: database.json.bak

[4] Application Logs
    â””â”€ discord.py logs
    â””â”€ Set LOG_LEVEL in main.py to control verbosity

MONITORING COMMANDS:

!status                          â† Bot health & uptime
!logs [count]                    â† Recent log entries
!health                          â† Detailed system info
!queue                           â† Pending operations


ğŸ”„ BACKUP & RECOVERY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

AUTOMATIC BACKUPS:

Daily Backups:
  â€¢ database.json.bak created each day
  â€¢ Keeps last 7 days of backups
  â€¢ Can restore with: cp database.json.bak database.json

MANUAL BACKUP:
  1. Copy database.json to safe location
  2. Run: python -m json.tool database.json (validates)
  3. Store in cloud (Google Drive, OneDrive, GitHub, etc.)

RECOVERY:

If data is corrupted:
  1. Stop bot: Ctrl+C
  2. Restore: cp database.json.bak database.json
  3. Restart: python main.py

If all backups lost:
  1. Delete database.json
  2. Restart bot
  3. Bot recreates empty database
  4. Users can re-add watchers, mirrors, etc.


âœ… VERIFICATION & TESTING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RUN VERIFICATION SCRIPT:

python verify_integration.py

CHECKS:
  âœ“ intelligent_command_processor.py exists
  âœ“ cogs/mandy_ai.py has integration
  âœ“ All imports work correctly
  âœ“ Processor can be instantiated
  âœ“ Pattern matching works
  âœ“ Sample commands recognize correctly

RUN UNIT TESTS:

python -m pytest tests/

MANUAL TESTING:

Test in Discord:

1. Basic command:
   User: "!help"
   Expected: Command list

2. DM command (intelligent):
   User: "dm yourself test"
   Expected: DM received from bot

3. Stats command:
   User: "stats daily"
   Expected: Message statistics

4. Watcher command:
   User: "watch yourself after 2 messages say hi"
   Expected: Watcher added

5. Permission check:
   User: (not admin) "!shutdown"
   Expected: "Permission denied" error


ğŸ“ GETTING HELP & SUPPORT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IF SOMETHING BREAKS:

1. Check console output for error messages
2. Read error â†’ identify which component failed
3. Try steps in "Troubleshooting" section (above)
4. Check database.json is valid JSON
5. Restart bot fresh

READING ERROR MESSAGES:

Example Error: "ImportError: No module named 'discord'"
  FIX: pip install discord.py

Example Error: "Permission Denied" in logs
  FIX: Check bot permissions in Discord server settings

Example Error: "Database corrupted"
  FIX: Restore from backup or delete to recreate


ğŸ“ LEARNING MORE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INCLUDED DOCUMENTATION:

1. MANDY_MANUAL.md (Original comprehensive manual)
2. README_INTELLIGENT_SYSTEM.txt (System overview)
3. INTEGRATION_COMPLETE.txt (Integration details)
4. QUICK_REFERENCE.txt (Command patterns)
5. SYSTEM_SUMMARY.txt (Component summary)
6. INTELLIGENT_SYSTEM_INTEGRATED.md (Technical details)

EXTERNAL RESOURCES:

Discord.py Documentation:
  https://discordpy.readthedocs.io/

Google Gemini AI:
  https://ai.google.dev/

Discord Developer Portal:
  https://discord.com/developers/

Python Best Practices:
  https://pep8.org/


ğŸ”¬ DEEP DIVE - DEVELOPER & OPERATIONAL GUIDE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

This section gives developers and operators a thorough, actionable reference to
extend, test, deploy, and debug the bot at production scale. Read the "Quick
Reference" first, then use this deep dive for development tasks.

A. Local Development Environment
--------------------------------

1) Python & Virtualenv
   â€¢ Requirement: Python 3.8+ (3.10 recommended)
   â€¢ Create venv: python -m venv .venv
   â€¢ Activate: .venv\Scripts\activate (Windows) or source .venv/bin/activate (Unix)
   â€¢ Install: pip install -r requirements.txt (create this file if missing)

2) Environment Variables
   â€¢ DISCORD_BOT_TOKEN - Required
   â€¢ MYSQL_HOST / MYSQL_USER / MYSQL_PASSWORD / MYSQL_DB - Optional
   â€¢ GEMINI_API_KEY - Optional (for AI features)
   â€¢ LOG_LEVEL - DEBUG/INFO/WARNING/ERROR

3) Recommended Tools
   â€¢ Black (formatting): pip install black
   â€¢ Flake8 (linting): pip install flake8
   â€¢ pytest (tests): pip install pytest
   â€¢ pre-commit (hook automation)

4) Running Locally
   â€¢ Start dev instance: set DISCORD_BOT_TOKEN=token && python main.py
   â€¢ Run tests: python -m pytest tests/
   â€¢ Lint: flake8 .

B. Codebase Reference (Key Files & Public APIs)
-----------------------------------------------

1) intelligent_command_processor.py
   â€¢ IntentRecognizer.recognize(raw_input: str) -> Dict
     - Returns: {action, confidence, matches, raw_input}
     - Add patterns to INTENT_PATTERNS; be mindful of order and greediness
   â€¢ ArgumentExtractor (internal)
     - Converts regex groups into structured args
   â€¢ ContextMemory
     - Stores last 20 actions per user for pronoun resolution
   â€¢ ClarificationHandler
     - Presents choices with emoji reactions and awaits confirmation
   â€¢ ConfirmationFormatter
     - Builds embeds and success/failure messages
   â€¢ IntelligentCommandProcessor.process(text, user, guild, channel, executor)
     - Entry point: returns True if handled

2) cogs/mandy_ai.py
   â€¢ _ManydAICommandExecutor
     - send_dm(targets: List[int], text: str)
     - add_watcher(target_user_id: int, count: int, text: str)
     - remove_watcher(target_user_id: int)
     - list_watchers() -> list
     - create_mirror(source_channel_id: int, dest_channel_id: int)
     - show_stats(scope: str = "daily", user_id: int = None)
     - show_health()
     - show_queue()
   â€¢ _handle_fast_path(text, user, guild, channel)
     - Initializes executor and calls processor.process
     - IMPORTANT: wrap in try/except to ensure fallback returns to traditional parser

3) main.py
   â€¢ Bot startup, on_ready, event loop management
   â€¢ Database load/save (database.json or MySQL)
   â€¢ Register cogs and extensions

4) capability_registry.py / tool_plugin_manager.py
   â€¢ Registry APIs: enable_capability(guild_id, name), disable_capability(...)
   â€¢ Plugin API: register_tool(name, entry_point: Callable)
   â€¢ Ensure plugin code is sandboxed and validated by extensions/validator.py

C. Adding a New Intent (Step-by-step)
-------------------------------------

1) Add regex pattern to IntentRecognizer.INTENT_PATTERNS under a new
   action name (e.g. "set_reminder"). Order matters; place specific patterns
   before generic ones.

2) Add extraction logic in ArgumentExtractor (if needed) or provide named
   capture groups in your regex to simplify mapping.

3) Create executor method in _ManydAICommandExecutor (e.g. set_reminder(...)).
   Ensure it returns True/False and raises meaningful exceptions.

4) Add unit tests in tests/test_intents.py covering:
   â€¢ Recognizer matches sample utterances
   â€¢ Executor performs correct side effects
   â€¢ Clarification flows for ambiguous inputs

5) Add docs to QUICK_REFERENCE.txt and MANDY_MANUAL.md with examples.

D. Clarification & Reaction Flow (Concurrency Notes)
---------------------------------------------------

â€¢ The ClarificationHandler posts a message with numbered options and adds
  reaction emojis (1ï¸âƒ£, 2ï¸âƒ£, etc.).
â€¢ It waits for the message author to react within a timeout (default: 30s).
â€¢ If the author does not respond, the clarification expires and the bot
  cancels the operation.
â€¢ Edge cases:
  - Multiple users can trigger clarifications simultaneously; each uses a
    separate message and timeout tracked in memory.
  - Reactions from non-author are ignored for that clarification flow.

E. Database & MySQL Migration Guide
----------------------------------

Current format: database.json (auto-migrates to MySQL if configured)

Key tables for SQL migration (example schema):

-- watchers
CREATE TABLE watchers (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  guild_id BIGINT NOT NULL,
  owner_user_id BIGINT NOT NULL,
  target_user_id BIGINT NOT NULL,
  threshold INT NOT NULL,
  message_text TEXT,
  current_count INT DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- mirrors
CREATE TABLE mirrors (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  guild_id BIGINT NOT NULL,
  source_channel_id BIGINT NOT NULL,
  dest_channel_id BIGINT NOT NULL,
  created_by BIGINT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- message_counts
CREATE TABLE message_counts (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  guild_id BIGINT NOT NULL,
  channel_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  count BIGINT DEFAULT 0,
  last_message_ts INT
);

Migration steps:
  â€¢ Create MySQL DB and tables
  â€¢ Configure credentials via env vars
  â€¢ Start bot; it detects MySQL and will migrate JSON -> MySQL
  â€¢ Verify by running verify_integration.py

F. Deployment & Scaling
-----------------------

1) Docker (recommended for repeatable deploys)
   â€¢ Provide a minimal Dockerfile that installs Python, copies the repo,
     injects env vars, and runs python main.py

2) Orchestrate with docker-compose
   â€¢ Services: bot, mysql, redis (optional for cache), prometheus (optional)

3) Run as a Windows service or systemd for production hostless
   â€¢ Use pm2 or NSSM on Windows for process supervision

4) Scaling horizontally
   â€¢ Use a single MySQL instance for shared state
   â€¢ Use Redis (or DB) to coordinate locks for jobs and watchers
   â€¢ Avoid multiple bots sending the same action: use leader election or
     a task queue (RabbitMQ/Redis) to ensure single-writer semantics

G. Observability & Metrics
--------------------------

Suggested metrics to export (Prometheus):
  â€¢ mandy_commands_processed_total{action}
  â€¢ mandy_command_errors_total{action,reason}
  â€¢ mandy_command_latency_seconds_bucket
  â€¢ mandy_active_watchers_total
  â€¢ mandy_gemini_requests_total

Logging notes:
  â€¢ Use structured logs (JSON) if shipping to ELK/CloudWatch
  â€¢ Log levels controlled by LOG_LEVEL env var
  â€¢ Sanitize logs to avoid leaking tokens or private messages

H. Security Checklist
---------------------

  â€¢ Keep tokens and secrets out of source control (passwords.txt should be
    in .gitignore). Use secret managers in production.
  â€¢ Limit bot role permissions to only what's necessary
  â€¢ Validate plugin code with extensions/validator.py before loading
  â€¢ Rate-limit AI calls and block large payloads from untrusted users
  â€¢ Monitor logs and set alerts for anomalous activity

I. Advanced Troubleshooting
---------------------------

Common failure: "Intelligent processor returns action=None"
  â€¢ Reproduce with sample utterances using python -c "from
    intelligent_command_processor import IntentRecognizer; print(IntentRecognizer().recognize('text'))"
  â€¢ If patterns don't match, add or adjust regex patterns; write tests
  â€¢ Use regex101.com to iterate quickly

Clarification race conditions:
  â€¢ Verify the author id check in reaction handler
  â€¢ Ensure timeouts are handled and cleanup tasks delete pending clarifications

Gemini API failures:
  â€¢ Inspect rate limit headers and backoff behavior
  â€¢ Ensure GEMINI_API_KEY is valid and not expired
  â€¢ Add retries with exponential backoff (already present)

J. Testing & CI
---------------

  â€¢ Unit tests: tests/test_mandy_ai.py, tests/test_docs.py â€” extend these
  â€¢ Add tests for new intents and executor behaviors
  â€¢ CI pipeline suggestions:
     - Run flake8, black --check
     - Run pytest, collect coverage
     - Run verification script python verify_integration.py

K. Contribution & PR Checklist
------------------------------

When opening a PR:
  â€¢ Run linting & tests locally
  â€¢ Add unit tests for new behavior
  â€¢ Update docs/ with examples and expected outputs
  â€¢ Describe migration steps if DB changes
  â€¢ Tag reviewers and include screenshots or logs for UI changes

L. Example: Add "set_reminder" intent (code snippet)
----------------------------------------------------

1) Add pattern to IntentRecognizer.INTENT_PATTERNS['set_reminder'] = [
   r"^(?:set|remind)\s*(.+?)\s+in\s+(\d+)\s*(?:minutes|mins|m)\s*(?:to\s+)?(.+)$",
]

2) Add executor in _ManydAICommandExecutor:
   async def set_reminder(self, user_id: int, minutes: int, text: str):
       # schedule reminder job, return True on success
       pass

3) Add tests and docs

ğŸ”¬ DEEP DIVE - DEVELOPER PLAYBOOK (COMPREHENSIVE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Below is an expanded "Developer Playbook" covering every command in depth,
file responsibilities, how to build, diagnostic steps, tests, and the
architectural/design rationale that guided key decisions (including the
intent/prompt choices used by the intelligent processor).

1) COMMAND REFERENCE â€” DEEP
----------------------------

send_dm (action: send_dm)
  â€¢ User examples:
    - "dm @john hello"
    - "message john 'hey there'"
  â€¢ Executor: _ManydAICommandExecutor.send_dm(targets: List[int], text: str)
  â€¢ Behavior:
    - Fuzzy-match username
    - If multiple matches â†’ ClarificationHandler
    - Attempts DM; falls back to reply if DMs are blocked
  â€¢ Logs to check:
    - Console: "send_dm" action log
    - database.json: no persistent record unless configured
  â€¢ Diagnostics:
    - If DM fails: check target privacy settings & bot DM permission
    - Reproduce: python -c "from intelligent_command_processor import IntentRecognizer; print(IntentRecognizer().recognize('dm john hi'))"
  â€¢ Tests to write:
    - Recognizer matches various utterances
    - send_dm handles blocked DMs gracefully

add_watcher (action: add_watcher)
  â€¢ User examples:
    - "watch john after 5 messages say hey"
    - "add watcher john 5 say hey"
  â€¢ Executor: add_watcher(target_user_id: int, count: int, text: str)
  â€¢ Behavior:
    - Adds watcher record to database.json (or MySQL)
    - Increments message counts on subsequent messages
    - When threshold reached â†’ sends the configured text
  â€¢ Logs to check:
    - database.json.watchers
    - watcher trigger logs in console
  â€¢ Diagnostics:
    - If not triggering: verify message_counts increments for target user
    - Check watcher entry 'threshold' and 'current'
  â€¢ Tests:
    - Add watcher and simulate messages; assert trigger runs

remove_watcher (action: remove_watcher)
  â€¢ Examples: "stop watching john", "remove watcher john"
  â€¢ Executor: remove_watcher(target_user_id: int)
  â€¢ Behavior: Removes watcher entry; send confirmation
  â€¢ Diagnostics: Confirm entry removed from database.json
  â€¢ Tests: Ensure removal works when multiple watchers exist

list_watchers (action: list_watchers)
  â€¢ Examples: "show watchers", "list watchers"
  â€¢ Executor: list_watchers() -> list
  â€¢ Behavior: Returns list of watchers readable by the caller (respect permissions)
  â€¢ Diagnostics: Check DB and command output formatting
  â€¢ Tests: Covers empty and multiple watchers

mirror (action: mirror)
  â€¢ Examples: "mirror #general to #backup", "link #a with #b"
  â€¢ Executor: create_mirror(source: str, dest: str)
  â€¢ Behavior:
    - Stores mapping in database.json/mirrors
    - Hooks into on_message to forward messages
    - Preserves basic metadata (author, attachments)
  â€¢ Diagnostics:
    - Ensure bot permission to read in source and send in dest
    - Check mirrors table/JSON
  â€¢ Tests:
    - Mirror message forwarding including attachments, edits, deletes

show_stats (action: show_stats)
  â€¢ Examples: "show stats", "stats daily", "how much has john messaged today"
  â€¢ Executor: show_stats(scope: str = "daily", user_id: int = None)
  â€¢ Behavior: Aggregates message_counts and formats top-talkers and user stats
  â€¢ Diagnostics:
    - Check message_counts table/JSON for aggregation windows
    - Verify time-window alias mapping (todayâ†’daily)
  â€¢ Tests: Aggregation correctness for windows and user filters

show_health (action: show_health)
  â€¢ Examples: "health", "status"
  â€¢ Executor: show_health()
  â€¢ Behavior: Returns uptime, latency, queue status, memory usage
  â€¢ Diagnostics: Check background worker health and DB connectivity
  â€¢ Tests: Return values when parts of infrastructure are down

show_queue (action: show_queue)
  â€¢ Examples: "queue", "show queue"
  â€¢ Executor: show_queue()
  â€¢ Behavior: Returns pending job list, ages, and retry counts
  â€¢ Diagnostics: Inspect job queue store (in-memory or DB/Redis)
  â€¢ Tests: Ensure job states (pending, running, failed) are reported

2) FILE REFERENCE â€” DEEP (What each file REALLY owns)
------------------------------------------------------

main.py
  â€¢ Responsible for: startup, configuration parsing, DB init, cog registration,
    and graceful shutdown.
  â€¢ Key functions to inspect:
    - load_database(), save_database(), on_ready(), on_error()
  â€¢ Diagnostics:
    - If bot won't start, check token env variable and on_ready exceptions

cogs/mandy_ai.py
  â€¢ Responsible for: user-facing commands, executor adapter, integrating the
    intelligent processor, command fallback, and safety checks.
  â€¢ Key places:
    - _handle_fast_path() â€” entry point for intelligent routing
    - _ManydAICommandExecutor class â€” actual side-effect methods
  â€¢ Diagnostics:
    - If intelligent path not firing: verify INTELLIGENT_PROCESSOR_AVAILABLE
    - If fallback begins, inspect exception logs from processor integration

intelligent_command_processor.py
  â€¢ Responsible for: NLP-style intent recognition, argument extraction, context
    memory, pronoun resolution, and clarification flows.
  â€¢ Key areas:
    - INTENT_PATTERNS â€” shape behavior and recognition
    - ContextMemory implementation â€” size limits and eviction policy
    - ClarificationHandler â€” reaction/message timeouts
  â€¢ Diagnostics:
    - Use IntentRecognizer.recognize to test pattern matching
    - Add unit tests for ambiguous utterances

capability_registry.py
  â€¢ Responsible for feature toggles per-guild
  â€¢ Diagnostics:
    - If a feature is unexpectedly disabled, query registry state for the guild

tool_plugin_manager.py
  â€¢ Responsible for dynamic tool loading and sandboxing
  â€¢ Diagnostics:
    - Ensure validator checks pass before loading external code

resolver.py
  â€¢ Responsible for member & role resolution and fuzzy ranking
  â€¢ Diagnostics:
    - If fuzzy matching fails often, check rank_members() thresholds

intelligence_layer.py
  â€¢ Responsible for AI routing and schema enforcement
  â€¢ Key notes:
    - Enforces SCHEMA_KEYS (intent, response, actions, tool_design, build, confirm)
    - Handles model-specific backoffs and retries
  â€¢ Diagnostics:
    - If model returns invalid schema, check validation and fallback behavior

extensions/
  â€¢ Plugins live here. Use validators before loading.
  â€¢ Diagnostics:
    - Uncaught exceptions in plugins should be captured and disabled

tests/
  â€¢ Unit tests & integration checks
  â€¢ Extend tests for new intents and edge cases

3) BUILD / DEPLOY (Concretely: Dockerfile + CI example)
-------------------------------------------------------

Dockerfile (example):

FROM python:3.10-slim
WORKDIR /app
COPY . /app
RUN pip install --no-cache-dir -r requirements.txt
ENV PYTHONUNBUFFERED=1
CMD ["python", "main.py"]

docker-compose.yml snippet:

version: '3.8'
services:
  bot:
    build: .
    environment:
      - DISCORD_BOT_TOKEN=${DISCORD_BOT_TOKEN}
      - MYSQL_HOST=mysql
      - MYSQL_USER=root
      - MYSQL_PASSWORD=password
    depends_on:
      - mysql
  mysql:
    image: mysql:8
    environment:
      MYSQL_ROOT_PASSWORD: password
    volumes:
      - db-data:/var/lib/mysql
volumes:
  db-data:

CI (GitHub Actions - minimal):

name: CI
on: [push, pull_request]
jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with: python-version: '3.10'
      - run: python -m pip install -r requirements.txt
      - run: pip install -r requirements.txt
      - run: flake8 .
      - run: black --check .
      - run: pytest -q

4) DIAGNOSTICS & REPRODUCTION CHECKLISTS
----------------------------------------

When a command fails for a user:
  1) Check console logs (set LOG_LEVEL=DEBUG temporarily)
  2) Reproduce locally with a minimal test that calls IntentRecognizer
     and executor methods directly
  3) Verify DB state (database.json or MySQL rows)
  4) If clarification was expected, check Clarification message & reactions
  5) Inspect rate limits & cooldowns for that user
  6) Check bot permissions in the relevant channels

Useful reproduction commands:
  â€¢ python -c "from intelligent_command_processor import IntentRecognizer; print(IntentRecognizer().recognize('watch john after 5 messages say hey'))"
  â€¢ Run individual executor methods in an integration test with mocked Discord objects

Logging & Telemetry to enable:
  â€¢ Increase LOG_LEVEL
  â€¢ Stream logs to a remote system with JSON formatting
  â€¢ Expose Prometheus metrics and set alerts on error rates

5) DESIGN RATIONALE â€” WHY THINGS ARE THIS WAY
---------------------------------------------

Intent Recognition using ordered regex patterns:
  â€¢ Regex is deterministic and fast for clearly-defined command families.
  â€¢ Order matters: specific patterns first avoid overmatching by generic ones.
  â€¢ Easier to test and reason about than a free-form LLM for critical
    control commands.

Confidence heuristic (pattern-length based):
  â€¢ Uses a simple heuristic (0.70 + len(pattern)*0.01 capped) to indicate
    pattern specificity. It's lightweight and explains behavior.

Fallback to traditional parser:
  â€¢ Safety: if NLP fails, bot retains old, proven behavior.
  â€¢ Predictability: Admins can rely on explicit prefix commands when needed.

Clarification via reactions:
  â€¢ Lightweight, quick UX inside Discord; no extra stateful UI needed.
  â€¢ Reaction-based decisions are visible and easy to audit.

Pronoun resolution (ContextMemory):
  â€¢ Small, per-user ring-buffer (20 items) avoids keeping long histories
    and limits contextual leakage/private data exposure.

Fuzzy matching (difflib):
  â€¢ Easy to understand edit-distance-like measure for name similarity
  â€¢ Tunable threshold to reduce false positives

AI (Gemini) use for heavy requests only:
  â€¢ Use LLMs for open-ended or heavy compute tasks (explainers, code)
  â€¢ Keep control commands deterministic (regex) for safety
  â€¢ Schema enforcement reduces hallucination risk

6) PROMPT & SCHEMA DESIGN (Why the prompt is built this way)
-----------------------------------------------------------

Systematic prompt patterns used in intelligence_layer.py:
  â€¢ System prompt sets clear rules: format, short, factual, no hallucinations
  â€¢ Use of SCHEMA_KEYS to request a structured response (intent, response,
    actions)
  â€¢ Few-shot examples for tricky interpretations (ambiguous names, pronouns)
  â€¢ Expect a small, structured JSON-like output to allow deterministic parsing

Reasons:
  â€¢ Minimizes ambiguous outputs that would otherwise require complex parsing
  â€¢ Makes the model useful for decision-making (what to do) rather
    than for side-effecting directly without checks
  â€¢ Ensures the bot can validate and confirm actions before executing

7) MAINTAINABILITY & CONTRIBUTION GUIDELINES
--------------------------------------------

  â€¢ Keep intent patterns small and specific; add tests for each new pattern
  â€¢ Avoid heavy side effects inside the recognizer: extract arguments only
  â€¢ Write clear docstrings and update docs/ for any behavior changes
  â€¢ Keep ClarificationHandler and executor logic separate for testability

8) SAMPLES & DEBUG SCRIPTS
-------------------------

Quick regex tester script (debug_regex.py):
  from intelligent_command_processor import IntentRecognizer
  r = IntentRecognizer()
  examples = [
    'dm john hello',
    'watch john after 5 messages say hey',
    'mirror #general to #backup',
  ]
  for e in examples:
    print(e, 'â†’', r.recognize(e))

Utility: "replay_last_actions.py" to reenact recent actions from database.json


ğŸ¯ WRAP-UP
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

This Developer Playbook extends the Quick Guide with actionable, testable
instructions for building, deploying, diagnosing, and reasoning about why the
system is implemented the way it is. If you'd like, I can:
  â€¢ Add a Dockerfile + GitHub Actions workflow to the repo
  â€¢ Create per-command unit test templates in tests/
  â€¢ Generate a Prometheus metrics exporter stub

Tell me which of those you'd like next and I'll add it.



ğŸ¯ QUICK COMMAND REFERENCE (SUMMARY)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

USER COMMANDS:

Natural Language (New):
  â€¢ "dm john hello"
  â€¢ "message john what's up"
  â€¢ "watch john after 5 messages say hey"
  â€¢ "show watchers"
  â€¢ "mirror #general #backup"
  â€¢ "stats daily"
  â€¢ "health"
  â€¢ "queue"

Traditional Prefix (Still Works):
  â€¢ !dm @john hello
  â€¢ !watcher john 5 hey
  â€¢ !list_watchers
  â€¢ !stats
  â€¢ !help


ADMIN COMMANDS (God-level):

  â€¢ !reload_capabilities
  â€¢ !restrict <cmd> <level>
  â€¢ !status
  â€¢ !shutdown
  â€¢ !logs [count]
  â€¢ !reload_tools


EMOJI REACTIONS:

Confirmation:
  â€¢ âœ… Confirm action
  â€¢ âŒ Cancel action
  â€¢ ğŸ”„ Retry action
  â€¢ â­ï¸  Skip action
  â€¢ 1ï¸âƒ£  2ï¸âƒ£  3ï¸âƒ£  ... Select option in clarification


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

              ğŸ‰ YOU NOW UNDERSTAND THE ENTIRE BOT! ğŸ‰

                    Ready to get started? Run:
                         python main.py

             Questions? Check docs/ folder or read this file again!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
